syntax = "proto2";

package roadstar.common.adapter;

// Property of a certain Input/Output that will be used by a module.
message AdapterConfig {
  enum MessageType {
    CHASSIS = 1;
    CHASSIS_DETAIL = 2;
    CONTROL_COMMAND = 3;
    CONTROL_DEBUG = 4;
    LOCALIZATION = 5;
    MONITOR = 6;
    FUSION_MAP = 7;
    PAD = 8;
    PLANNING_TRAJECTORY = 9;
    POINT_CLOUD = 10;
    TRAFFIC_LIGHT_DETECTION = 12;
    CONTROL_STATUS = 13;
    RSDS = 14;
    ESR = 15;
    VLP_POINT_CLOUD1 = 17;
    VLP_POINT_CLOUD2 = 18;
    VLP_POINT_CLOUD3 = 19;
    VLP_POINT_CLOUD4 = 20;
    SYSTEM_STATUS = 21;
    LANE_DETECTION = 22;
    RADAR_FILTER = 23;
    INS = 24;
    CAMERA_HEAD_LEFT = 25;
    CAMERA_HEAD_RIGHT = 26;
    CAMERA_FRONT_LEFT = 27;
    CAMERA_FRONT_RIGHT = 28;
    CAMERA_MID_LEFT = 29;
    CAMERA_MID_RIGHT = 30;
    CAMERA_TAIL_LEFT = 31;
    CAMERA_TAIL_RIGHT = 32;
    CAMERA_TRAFFIC_LIGHT = 109;
    COMPRESSED_CAMERA_HEAD_LEFT = 33;
    COMPRESSED_CAMERA_HEAD_RIGHT = 34;
    COMPRESSED_CAMERA_FRONT_LEFT = 35;
    COMPRESSED_CAMERA_FRONT_RIGHT = 36;
    COMPRESSED_CAMERA_MID_LEFT = 37;
    COMPRESSED_CAMERA_MID_RIGHT = 38;
    COMPRESSED_CAMERA_TAIL_LEFT = 39;
    COMPRESSED_CAMERA_TAIL_RIGHT = 40;
    COMPRESSED_CAMERA_TRAFFIC_LIGHT = 110;
    CAMERA_HEAD_LEFT_PROTO = 111;
    CAMERA_HEAD_RIGHT_PROTO = 112;
    CAMERA_FRONT_LEFT_PROTO = 113;
    CAMERA_FRONT_RIGHT_PROTO = 114;
    CAMERA_MID_LEFT_PROTO = 115;
    CAMERA_MID_RIGHT_PROTO = 116;
    CAMERA_TAIL_LEFT_PROTO = 117;
    CAMERA_TAIL_RIGHT_PROTO = 118;
    CAMERA_TRAFFIC_LIGHT_PROTO = 119;
    COMPRESSED_CAMERA_HEAD_LEFT_PROTO = 120;
    COMPRESSED_CAMERA_HEAD_RIGHT_PROTO = 121;
    COMPRESSED_CAMERA_FRONT_LEFT_PROTO = 122;
    COMPRESSED_CAMERA_FRONT_RIGHT_PROTO = 123;
    COMPRESSED_CAMERA_MID_LEFT_PROTO = 124;
    COMPRESSED_CAMERA_MID_RIGHT_PROTO = 125;
    COMPRESSED_CAMERA_TAIL_LEFT_PROTO = 126;
    COMPRESSED_CAMERA_TAIL_RIGHT_PROTO = 127;
    COMPRESSED_CAMERA_TRAFFIC_LIGHT_PROTO = 128;
    DELPHIESR = 41;
    CONTI_RADAR = 43;
    GPS = 44;
    IMU = 45;
    RAW_IMU = 46;
    INS_STAT = 47;
    INS_STATUS = 48;
    GNSS_STATUS = 49;
    GNSS_RTK_OBS = 50;
    GNSS_RTK_EPH = 51;
    GNSS_BEST_POSE = 52;
    GNSS_RAW_DATA = 53;
    GNSS_HEADING = 54;
    STREAM_STATUS = 55;
    RTCM_DATA = 56;
    LIDAR_PERCEPTION = 57;
    PLUTO_IMU = 60;
    CONTI_RADAR_TAIL_LEFT = 61;
    CONTI_RADAR_TAIL_RIGHT = 62;
    CONTI_RADAR_HEAD_MIDDLE = 63;
    CONTI_RADAR_HEAD_LEFT = 64;
    CONTI_RADAR_HEAD_RIGHT = 65;
    ASENSING_INS = 66;
    ASENSING_INS_STATUS = 67;
    GNSS_INS = 80;
    RSLIDAR_MID_LEFT = 68;
    RSLIDAR_MID_RIGHT = 69;
    RSLIDAR_TOP_LEFT = 70;
    RSLIDAR_TOP_RIGHT = 71;
    VISION_LANE = 98;
    OLD_CAMERA_OBSTACLES = 99;
    CAMERA_OBSTACLES = 100;
    LIDAR_OBSTACLES = 101;
    RADAR_OBSTACLES = 102;
    HESAI_POINT_CLOUD = 103;
    VELO64_PACKETS = 104;
    HESAI_PACKETS = 105;
    VLP1_PACKETS = 106;
    VLP2_PACKETS = 107;
    VLP3_PACKETS = 108;
    LIDAR_POINT_CLOUD_MAIN = 200;
    LIDAR_POINT_CLOUD_HEAD_MID = 201;
    LIDAR_POINT_CLOUD_TAIL_LEFT = 202;
    LIDAR_POINT_CLOUD_TAIL_RIGHT = 203;
    LIDAR_POINT_CLOUD_TAIL_MID = 216;
    LIDAR_POINT_CLOUD_TOP_LEFT = 217;
    LIDAR_POINT_CLOUD_TOP_RIGHT = 218;
    LIDAR_POINT_CLOUD_HEAD_LEFT = 219;
    LIDAR_POINT_CLOUD_HEAD_RIGHT = 220;
    LIDAR_PACKET_MAIN = 204;
    LIDAR_PACKET_HEAD_MID = 205;
    LIDAR_PACKET_TAIL_LEFT = 206;
    LIDAR_PACKET_TAIL_RIGHT = 207;
    SYNC_LIDAR_HEAD = 208;
    SYNC_LIDAR_FRONT_LEFT = 209;
    SYNC_LIDAR_FRONT_RIGHT = 210;
    SYNC_LIDAR_MID_LEFT = 211;
    SYNC_LIDAR_MID_RIGHT = 212;
    SYNC_LIDAR_TAIL_LEFT = 213;
    SYNC_LIDAR_TAIL_RIGHT = 214;
    MESSAGE_SERVICE_STATUS = 215;
    ULTRASONIC_RADAR_FRONT = 221;
    ULTRASONIC_RADAR_MID = 222;
    ULTRASONIC_RADAR_REAR = 223;
  }
  enum Mode {
    RECEIVE_ONLY = 0;
    PUBLISH_ONLY = 1;
    DUPLEX = 2;
    RECEIVE_HEADER = 3;  // The adapter only receive message headers.
  }
  required MessageType type = 1;
  required Mode mode = 2;
  // The max number of received messages to keep in the adapter, this field
  // is not useful for PUBLISH_ONLY mode messages.
  optional int32 message_history_limit = 3 [default = 10];
}

// A config to specify which messages a certain module would consume and
// produce.
message AdapterManagerConfig {
  repeated AdapterConfig config = 1;
  required bool is_ros = 2;  // Whether the message comes from ROS
  optional string module_name = 3;
}
