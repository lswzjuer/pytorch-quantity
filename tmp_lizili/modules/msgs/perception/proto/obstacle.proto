syntax = "proto2";

package roadstar.perception;

import "modules/msgs/perception/proto/geo.proto";

// Next id is 35
message Obstacle {
  // ======= Detection fileds =======
  // obstacle ID.
  optional int32 id = 1;
  // GPS time in seconds.
  optional double timestamp = 2;
  // obstacle position in the world coordinate system.
  optional Vector2d position = 3;
  // obstacle 2d bounding box in camera coordinate.
  // optional ImgBox2d img_box = 42;
  // not used
  repeated Vector2d polygon_point = 4;
  // heading (of obstacle box) in the world coordinate system.
  optional double theta = 10;
  // Size of obstacle bounding box.
  optional double length = 5;  // obstacle length.
  optional double width = 6;   // obstacle width.
  optional double height = 7;  // obstacle height.

  optional double tracking_length = 28;  // length from tracking
  optional double tracking_width = 29;   // width from tracking
  // grids occupied by this obstacle.
  repeated int32 occupied_grids = 27 [packed = true];

  enum ObjectType {
    UNKNOWN = 0;
    UNKNOWN_MOVABLE = 1;
    UNKNOWN_UNMOVABLE = 2;
    PEDESTRIAN = 3;  // Pedestrian, usually determined by moving behaviour.
    BICYCLE = 4;     // Bike, motor bike
    VEHICLE = 5;     // Passenger car or truck.
    CAR = 6;         // Passenger car.
    TRUCK = 7;       // Truck.
    BUS = 8;
    TRICYCLE = 9;
    BLOCK = 10;
  };
  optional ObjectType object_type = 8;  // obstacle type
  // Probability of each type, used for track type.
  repeated double type_probs = 9;

  // ======= tracking ======
  optional double velocity = 11;  // obstacle velocity.
  optional double angular_velocity = 12;
  optional double acceleration = 13;
  // not used
  optional double angular_acceleration = 14;
  // moving heading
  optional double heading = 25;

  // duration of an obstacle since detection in s.
  optional double tracking_time = 15;
  optional int32 detection_times = 16;
  optional int32 track_id = 17;
  optional double latest_tracked_time = 18;

  // Just for offline debuging, onboard will not fill this field.
  // Format like : [x0, y0, z0, x1, y1, z1...]
  repeated double point_cloud = 19 [packed = true];

  // not used
  optional Vector2d position_std = 20;
  optional double velocity_std = 21;
  optional double angular_velocity_std = 22;
  optional double acceleration_std = 23;
  // not used
  optional double angular_acceleration_std = 24;
  optional double heading_std = 26;

  enum SensorSource {
    VELO64 = 0;  // High confidence.
    CAMERA = 1;  // High confidence on x, category and width, low confidence on
                 // y, with no velocity.
    RADAR = 2;   // High confidence on location and velocity, low confidence on
                 // width.
    CAMERA_RADAR = 3;  // High confidence.
    VELO16 = 4;
  }
  // observation sensor of the obstacle
  optional SensorSource sensor_source = 30 [default = VELO64];

  // sensor_id for sensor from the same source.
  optional int32 sensor_id = 41 [default = 0];

  // confidence of the obstacle by detetion.
  optional double confidence = 31;

  // lane id of the obstacle lied in (just for obstacles from camera)
  optional int32 in_lane_id = 32;

  // distance from lane center (just for obstacles from camera)
  optional double dis_from_lane_center = 33;

  // distance from our vehicle (just for obstacles from camera)
  optional double dis_from_ego = 34;

  optional string remark = 35;
}
